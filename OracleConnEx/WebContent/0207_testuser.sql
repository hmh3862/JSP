--================================================================
-- CONNECT BY 를 이용한 계층 쿼리
--================================================================
SELECT * FROM tdept;

-- 사장실 등록
insert into tdept (dept_code,dept_name, parent_dept, use_yn, area, boss_id)
values ('000000','사장실','  ','Y','서울','');

-- 상위부서 적용
update tdept 
set parent_dept='000000' where dept_code=parent_dept;

SELECT * FROM tdept; -- 11개

-- 부서를 상위부서부터 차례대로 단계를 붙여서 출력해보자!!!
SELECT 
	LEVEL, DEPT_CODE , DEPT_NAME 
FROM 
	tdept
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT ; -- 28개 : 모든 단계를 표시
	
SELECT 
	LEVEL, DEPT_CODE , DEPT_NAME 
FROM 
	tdept
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT START WITH DEPT_CODE = '000000'; -- 11개 : 최상위 부서를 지정	

SELECT 
	LEVEL, DEPT_CODE , DEPT_NAME 
FROM 
	tdept
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT START WITH DEPT_CODE = 'AA0001'; -- 3개 : 경영지원 부서만 나온다.	
	
SELECT 
	LEVEL, LPAD(DEPT_CODE, LEVEL*5, ' ') , 
	LPAD(DEPT_NAME, LEVEL*8, ' '), LPAD(' ',LEVEL*8,' ')|| DEPT_NAME 
FROM 
	tdept
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT START WITH DEPT_CODE = '000000';	

-- 조건을 where절에 주면 문제가 발생한다.
-- 없업 부서는 제외하여 조회하고 싶다.
SELECT 
	LEVEL, LPAD(DEPT_CODE, LEVEL*5, ' ') , 
	LPAD(DEPT_NAME, LEVEL*8, ' '), LPAD(' ',LEVEL*8,' ')|| DEPT_NAME 
FROM 
	tdept
WHERE 
	DEPT_CODE <> 'CA0001' -- 상위 부서명만 사라져서 영업지원내의 부서들이 기술지원 밑으로 들어가는 불상사가 생긴다.
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT START WITH DEPT_CODE = '000000';	

SELECT 
	LEVEL, LPAD(DEPT_CODE, LEVEL*5, ' ') , 
	LPAD(DEPT_NAME, LEVEL*8, ' '), LPAD(' ',LEVEL*8,' ')|| DEPT_NAME 
FROM 
	tdept
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT AND DEPT_CODE <> 'CA0001' -- 여기에 조건을 부여해야 모든 영업부서들이 제외된다.
	START WITH DEPT_CODE = '000000';	

-- START WITH 값을 변견하면 원하는 레벨의 값만 조회가 가능하다.
-- 기술지원부만 보고싶다.
SELECT 
	LEVEL, LPAD(DEPT_CODE, LEVEL*5, ' ') , LPAD(' ',LEVEL*8,' ')|| DEPT_NAME 
FROM 
	tdept
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT 
	START WITH DEPT_CODE = 'BA0001';	
	
-- 영업부만 보고싶다.
SELECT 
	LEVEL, LPAD(DEPT_CODE, LEVEL*5, ' ') , LPAD(' ',LEVEL*8,' ')|| DEPT_NAME 
FROM 
	tdept
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT 
	START WITH DEPT_CODE = 'CA0001';
	
-- 역전개도 가능할까요?
SELECT 
	LEVEL, LPAD(DEPT_CODE, LEVEL*5, ' ') , LPAD(' ',LEVEL*8,' ')|| DEPT_NAME 
FROM 
	tdept
CONNECT BY 
	PRIOR PARENT_DEPT = DEPT_CODE -- 여기변경
	START WITH DEPT_CODE = 'CD0001'; -- 여기변경

-- 역전개의 잘못된 방법
SELECT 
	LEVEL, LPAD(DEPT_CODE, LEVEL*5, ' ') , LPAD(' ',LEVEL*8,' ')|| DEPT_NAME 
FROM 
	tdept
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT -- 여기를 변경하지 않으면 역전개가 되지 않는다.
	START WITH DEPT_CODE = 'CD0001'; -- 시작위치만 바꾸면 역전개가 되지 않는다.
	
SELECT 
	LEVEL, LPAD(DEPT_CODE, LEVEL*5, ' ') , LPAD(' ',LEVEL*8,' ')|| DEPT_NAME 
FROM 
	tdept
CONNECT BY 
	PRIOR PARENT_DEPT = DEPT_CODE   -- 여기를 변경하지 않으면 역전개가 되지 않는다.
	START WITH DEPT_CODE = '000000'; -- 시작위치만 바꾸면 역전개가 되지 않는다.

	
-- 부서장의 이름이 단계별로 나오게 하시오!!!!
-- 1) 부서장의 ID가 나온다.	
SELECT 
	LEVEL, LPAD(' ',LEVEL*8,' ')|| DEPT_NAME , LPAD(BOSS_ID, LEVEL*6, ' ')
FROM 
	tdept
CONNECT BY 
	PRIOR DEPT_CODE = PARENT_DEPT 
	START WITH DEPT_CODE = '000000';	
	
-- 2) 부서장의 이름은 temp테이블에 있다. 1의 결과와 조인을 하면 부서명과 부서장의 이름을 모두 조회가 가능하다.

SELECT 
	B.LEV, LPAD(B.DEPT_NAME,B.LEV*5,' '),LPAD(' ',B.LEV*5,' ')|| B.DEPT_NAME,  NVL(A.EMP_NAME,' ') 
FROM 
	temp A, 
	(SELECT LEVEL LEV, DEPT_NAME , LPAD(BOSS_ID, LEVEL*6, ' ') BOSS FROM tdept 
	 CONNECT BY PRIOR DEPT_CODE = PARENT_DEPT START WITH DEPT_CODE = '000000') B
WHERE 
	A.EMP_ID(+)  = B.BOSS;

-- ================================================================================
-- 5장. 랭킹
-- ================================================================================

CREATE TABLE SALE_HIST(
  SALE_DATE  DATE NOT NULL,
  SALE_SITE  VARCHAR2(10) NOT NULL,
  SALE_ITEM  VARCHAR2(10) NOT NULL,
  SALE_AMT   NUMBER,
  CONSTRAINT SALEHIST_PK PRIMARY KEY (SALE_DATE,SALE_SITE,SALE_ITEM)
);
INSERT INTO SALE_HIST VALUES('20010501','01','PENCIL',  5000);
INSERT INTO SALE_HIST VALUES('20010501','01','NOTEBOOK',9000);
INSERT INTO SALE_HIST VALUES('20010501','01','ERASER',  4500);
INSERT INTO SALE_HIST VALUES('20010501','02','PENCIL',  2500);
INSERT INTO SALE_HIST VALUES('20010501','02','NOTEBOOK',7000);
INSERT INTO SALE_HIST VALUES('20010501','02','ERASER',  3000);
INSERT INTO SALE_HIST VALUES('20010501','03','PENCIL',  2500);
INSERT INTO SALE_HIST VALUES('20010501','03','NOTEBOOK',7000);
INSERT INTO SALE_HIST VALUES('20010501','03','ERASER',  6000);
--
INSERT INTO SALE_HIST VALUES('20010502','01','PENCIL',  6000);
INSERT INTO SALE_HIST VALUES('20010502','01','NOTEBOOK',5000);
INSERT INTO SALE_HIST VALUES('20010502','01','ERASER',  5500);
INSERT INTO SALE_HIST VALUES('20010502','02','PENCIL',  3500);
INSERT INTO SALE_HIST VALUES('20010502','02','NOTEBOOK',7000);
INSERT INTO SALE_HIST VALUES('20010502','02','ERASER',  4000);
INSERT INTO SALE_HIST VALUES('20010502','03','PENCIL',  5500);
INSERT INTO SALE_HIST VALUES('20010502','03','NOTEBOOK',4500);
INSERT INTO SALE_HIST VALUES('20010502','03','ERASER',  5000);
--
INSERT INTO SALE_HIST VALUES('20010503','01','PENCIL',  7000);
INSERT INTO SALE_HIST VALUES('20010503','01','NOTEBOOK',6000);
INSERT INTO SALE_HIST VALUES('20010503','01','ERASER',  6500);
INSERT INTO SALE_HIST VALUES('20010503','02','PENCIL',  3500);
INSERT INTO SALE_HIST VALUES('20010503','02','NOTEBOOK',5000);
INSERT INTO SALE_HIST VALUES('20010503','02','ERASER',  5000);
INSERT INTO SALE_HIST VALUES('20010503','03','PENCIL',  6500);
INSERT INTO SALE_HIST VALUES('20010503','03','NOTEBOOK',3500);
INSERT INTO SALE_HIST VALUES('20010503','03','ERASER',  7000);
--
INSERT INTO SALE_HIST VALUES('20010504','01','PENCIL',  5500);
INSERT INTO SALE_HIST VALUES('20010504','01','NOTEBOOK',6500);
INSERT INTO SALE_HIST VALUES('20010504','01','ERASER',  3500);
INSERT INTO SALE_HIST VALUES('20010504','02','PENCIL',  7500);
INSERT INTO SALE_HIST VALUES('20010504','02','NOTEBOOK',5000);
INSERT INTO SALE_HIST VALUES('20010504','02','ERASER',  4000);
INSERT INTO SALE_HIST VALUES('20010504','03','PENCIL',  3500);
INSERT INTO SALE_HIST VALUES('20010504','03','NOTEBOOK',5500);
INSERT INTO SALE_HIST VALUES('20010504','03','ERASER',  3000);
COMMIT;

SELECT * FROM SALE_HIST sh;

-- 순위 구하기
SELECT 
	EMP_ID , EMP_NAME , SALARY ,
	DENSE_RANK () OVER (ORDER BY SALARY DESC) AS 순위1, -- 동률 처리 방식이 다르다.
	RANK () OVER (ORDER BY SALARY DESC) AS 순위2,
	RANK () OVER (ORDER BY SALARY) AS 순위3
FROM 
	temp;

-- 부서별 급여기준 순위를 보고싶다.
-- 1) 부서별 급여 합계
SELECT 
	DEPT_CODE , sum(SALARY)
FROM 
	temp
GROUP BY 
	DEPT_CODE ;
-- 2) 1의 결과에 순위를 출력
SELECT 
	DEPT_CODE , sum(SALARY), rank() OVER (ORDER BY sum(SALARY)) 순위
FROM 
	temp
GROUP BY 
	DEPT_CODE ;

SELECT 
	DEPT_CODE , sum(SALARY), rank() OVER (ORDER BY sum(SALARY) DESC) 순위
FROM 
	temp
GROUP BY 
	DEPT_CODE ;

SELECT 
	DEPT_CODE, EMP_ID , EMP_NAME , sum(SALARY),
	rank() OVER (PARTITION BY DEPT_CODE ORDER BY sum(SALARY) DESC)
FROM 
	TEMP
GROUP BY 
	DEPT_CODE , EMP_ID , EMP_NAME;


-- rollup이나 cube의 결과에까지 순위를 적용해 보자
-- 부서별 급여 합계 순위
SELECT 
	DEPT_CODE , EMP_ID , sum(SALARY),
	rank() OVER (PARTITION BY GROUPING(DEPT_CODE), GROUPING (EMP_ID) ORDER BY SUM(SALARY) DESC) 순위
FROM 
	temp
GROUP BY 
	ROLLUP(DEPT_CODE, EMP_ID);

-- 문제] sale_hits의 자료를 이용하여 일자별 매출 순위와 순위별 사업장 품목을 보여라!!!!
SELECT * FROM SALE_HIST sh;

SELECT 
	SH.*, 
	RANK() OVER (PARTITION BY SALE_DATE ORDER BY SALE_AMT DESC) 순위
FROM 
	SALE_HIST sh ;


SELECT 
	SH.*, 
	RANK() OVER (PARTITION BY SALE_SITE ORDER BY SALE_AMT DESC) 순위
FROM 
	SALE_HIST sh ;

-- CUME_DIST, PERCENT_RANK, NTILE(N), ROW_NUMBER()
SELECT 
	EMP_ID , EMP_NAME , SALARY ,
	rank() OVER (ORDER BY SALARY DESC) 순위1,
	CUME_DIST() OVER (ORDER BY SALARY DESC) 순위2,
	COUNT(SALARY) OVER (ORDER BY SALARY RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) 순위3
FROM 
	TEMP;

SELECT 
	EMP_ID , EMP_NAME , SALARY ,
	rank() OVER (ORDER BY SALARY ) 순위1,			-- 순위를 자연수로 표시
	CUME_DIST() OVER (ORDER BY SALARY ) 순위2,		-- 순위를 0~1사이의 실수로 표시
	PERCENT_RANK() OVER (ORDER BY SALARY)  순위3,	-- 퍼센트
	NTILE(5) OVER (ORDER BY SALARY ) 순위4,			-- n개의 그룹으로 나눈다.
	ROW_NUMBER() OVER (ORDER BY SALARY ) 순위5		-- 파티션 내의 실행된 ROW 순서의 일련번호
FROM 
	TEMP;

-- 입사년도별 급여의 합계를 구하라
SELECT 
	SUBSTR(EMP_ID, 1, 4), SUM(SALARY) 
FROM 
	TEMP t
GROUP BY 
	SUBSTR(EMP_ID, 1, 4); 

-- 입사연도별 차례대로 전부 나오게 하려면
SELECT 
	SUBSTR(EMP_ID, 1, 4), EMP_ID , EMP_NAME, SUM(SALARY) 
FROM 
	TEMP t
GROUP BY 
	SUBSTR(EMP_ID, 1, 4), EMP_ID , EMP_NAME 
ORDER BY 
	1;

-- 순위는 어떻게 구할까?
-- 위의 5개 함수를 이용하여 모두 조회해 보자
SELECT 
	SUBSTR(EMP_ID, 1, 4) 입사년도, EMP_ID , EMP_NAME, SUM(SALARY),
	rank() OVER (PARTITION BY SUBSTR(EMP_ID, 1, 4) ORDER BY SALARY ) RANK1,
	CUME_DIST () OVER (PARTITION BY SUBSTR(EMP_ID, 1, 4) ORDER BY SALARY ) RANK2,
	PERCENT_RANK() OVER (PARTITION BY SUBSTR(EMP_ID, 1, 4) ORDER BY SALARY ) RANK3,
	NTILE(2) OVER (PARTITION BY SUBSTR(EMP_ID, 1, 4) ORDER BY SALARY ) RANK4,
	ROW_NUMBER() OVER (PARTITION BY SUBSTR(EMP_ID, 1, 4) ORDER BY SALARY ) RANK5
FROM 
	TEMP t
GROUP BY 
	SUBSTR(EMP_ID, 1, 4), EMP_ID , EMP_NAME , SALARY ;

-- SALE_HITS의 자료를 이용하여 '01' 사업장의 품목별 당일 판매액과 
-- 당일까지의 누적 판매액을 구하는 쿼리

SELECT 
	S.*, SUM(SALE_AMT) OVER (PARTITION BY SALE_ITEM ORDER BY SALE_ITEM ROWS UNBOUNDED PRECEDING) 누계 
FROM 
	SALE_HIST S
WHERE 
	SALE_SITE = '01'
ORDER BY 
	SALE_ITEM , SALE_DATE ;

-- 일자별 사업장별 매출액과 사업장별 매출액의 3일 이동 평균을 구해보자(RANGE)
SELECT 
	SALE_DATE , SALE_SITE , SUM(SALE_AMT),
	AVG(SUM(SALE_AMT)) OVER (PARTITION BY SALE_SITE ORDER BY SALE_DATE RANGE INTERVAL '2' DAY PRECEDING) 이동평균
FROM 
	SALE_HIST S
GROUP BY 
	SALE_DATE, SALE_SITE , SALE_AMT ;

























































