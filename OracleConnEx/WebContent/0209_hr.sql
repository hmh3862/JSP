-- 41. 커미션을 버는 사원들의 부서와 연봉이 동일한 사원들의 LAST_NAME, 부서 번호 및 연봉을 조회한다.
SELECT e.DEPARTMENT_ID, SALARY FROM EMPLOYEES e WHERE e.COMMISSION_PCT IS NOT NULL AND DEPARTMENT_ID IS NOT NULL;
-- 멀티컬럼 멀티로우 서브쿼리!!!!
SELECT 
	LAST_NAME , DEPARTMENT_ID , SALARY 
FROM 
	EMPLOYEES e 
WHERE 
	(DEPARTMENT_ID, SALARY) IN (
		SELECT e.DEPARTMENT_ID, SALARY 
		FROM EMPLOYEES e 
		WHERE e.COMMISSION_PCT IS NOT NULL AND DEPARTMENT_ID IS NOT NULL
	);

-- 42. 위치 ID 가 1700 인 사원들의 연봉과 커미션이 동일한 사원들의 LAST_NAME, 부서 번호 및 연봉을 조회한다.
SELECT SALARY , NVL(COMMISSION_PCT, 0)
FROM EMPLOYEES e , DEPARTMENTS d 
WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID AND d.LOCATION_ID = 1700;

SELECT LAST_NAME 이름 , d1.DEPARTMENT_ID 부서 , SALARY 연봉 
FROM EMPLOYEES e1, DEPARTMENTS d1 
WHERE 
	  e1.DEPARTMENT_ID = d1.DEPARTMENT_ID 
	  AND 
	  (SALARY, NVL(COMMISSION_PCT, 0)) 
	  IN 
	  (
	    SELECT SALARY , NVL(COMMISSION_PCT, 0)
	    FROM EMPLOYEES e2 , DEPARTMENTS d2 
	    WHERE e2.DEPARTMENT_ID = d2.DEPARTMENT_ID AND d2.LOCATION_ID = 1700
	  )
ORDER BY 2, 3;
-- 다른 풀이
SELECT
	DISTINCT e.LAST_NAME 이름 , e.DEPARTMENT_ID 부서 , e.SALARY 연봉
FROM 
	(
		SELECT SALARY , NVL(COMMISSION_PCT, 0) COMMISSION_PCT
		FROM EMPLOYEES e , DEPARTMENTS d 
		WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID AND d.LOCATION_ID = 1700	
	) SAL1700, 
	EMPLOYEES e
WHERE 
	SAL1700.salary = e.SALARY AND SAL1700.COMMISSION_PCT = NVL(e.COMMISSION_PCT, 0)
ORDER BY 2, 3;
	 
	 
-- 43. LAST_NAME 이 'Kochhar' 인 사원과 동일한 연봉 및 커미션을 버는 사원들의 LAST_NAME, 부서 번호 및 연봉을 조회한다.
SELECT SALARY , NVL(COMMISSION_PCT,0) 
FROM EMPLOYEES e 
WHERE e.LAST_NAME = 'Kochhar';

SELECT LAST_NAME , DEPARTMENT_ID , SALARY 
FROM EMPLOYEES e
WHERE 
	(SALARY, NVL(COMMISSION_PCT, 0)) IN (SELECT SALARY , NVL(COMMISSION_PCT,0) FROM EMPLOYEES WHERE LAST_NAME = 'Kochhar')
	AND 
	LAST_NAME != 'Kochhar';
	 
-- 44. 직업 ID 가 SA_MAN 인 사원들이 받을 수 있는 최대 연봉 보다 높게 받는 사원들의 LAST_NAME, JOB_ID 및 연봉을 조회한다.
SELECT MAX(SALARY) FROM EMPLOYEES WHERE JOB_ID ='SA_MAN';
SELECT 
	LAST_NAME , JOB_ID , SALARY 
FROM 
	EMPLOYEES e 
WHERE 
	SALARY > (SELECT MAX(SALARY) FROM EMPLOYEES WHERE JOB_ID ='SA_MAN');

-- 45. 도시 이름이 T 로 시작하는 지역에 사는 사원들의 사번, LAST_NAME 및 부서 번호를 조회한다.
SELECT 
	e.EMPLOYEE_ID , e.LAST_NAME , e.DEPARTMENT_ID , l.CITY 
FROM 
	EMPLOYEES e , DEPARTMENTS d , LOCATIONS l 
WHERE 
	e.DEPARTMENT_ID = d.DEPARTMENT_ID AND d.LOCATION_ID = l.LOCATION_ID  AND l.CITY LIKE 'T%';

-- 46.  각 부서별 평균 연봉보다 더 받는 동일부서 근무사원들의
--      LAST_NAME, 연봉, 부서번호 및 해당 부서의 평균 연봉을 조회한다.
--      결과는 부서별 연봉을 기준으로 정렬한다.
SELECT  E.LAST_NAME , E.SALARY , E.DEPARTMENT_ID , V.DEP_AVG
FROM    EMPLOYEES E, 
		(
         SELECT  DEPARTMENT_ID , ROUND( AVG(SALARY), 0 ) DEP_AVG
         FROM    EMPLOYEES
         GROUP   BY DEPARTMENT_ID
        ) V
WHERE   E.DEPARTMENT_ID = V.DEPARTMENT_ID
AND     E.SALARY > V.DEP_AVG
ORDER   BY V.DEP_AVG;

-- 47. NOT EXISTS 연산자를 사용하여 매니저가 아닌 사원 이름을 조회한다.
SELECT * FROM EMPLOYEES ;
SELECT DISTINCT MANAGER_ID FROM EMPLOYEES WHERE MANAGER_ID IS NOT NULL ;

SELECT LAST_NAME FROM EMPLOYEES WHERE EMPLOYEE_ID NOT IN (SELECT DISTINCT MANAGER_ID FROM EMPLOYEES WHERE MANAGER_ID IS NOT NULL );

SELECT  FIRST_NAME , EMPLOYEE_ID , MANAGER_ID
FROM    EMPLOYEES E
WHERE   NOT EXISTS  (
                        SELECT  '1'
                        FROM    EMPLOYEES E2
                        WHERE   E.EMPLOYEE_ID = E2.MANAGER_ID
                    )
ORDER   BY EMPLOYEE_ID;

-- 48. 소속부서의 평균 연봉보다 적게 버는 사원들의 last_name 을 조회한다.
SELECT DEPARTMENT_ID , ROUND(AVG(SALARY)) FROM EMPLOYEES GROUP BY DEPARTMENT_ID ;

SELECT 
	DISTINCT d.DEPARTMENT_ID , DISTINCT e.LAST_NAME 
FROM 
	EMPLOYEES e , DEPARTMENTS d , (SELECT DEPARTMENT_ID , ROUND(AVG(SALARY),0) DEP_AVG FROM EMPLOYEES GROUP BY DEPARTMENT_ID) V
WHERE 
	SALARY < V.DEP_AVG;

-- 49. 각 사원 별 소속부서에서 자신보다 늦게 고용되었으나 보다 많은 연봉을 받는 사원이 존재하는 모든 사원들의 last_name 을 조회한다.

